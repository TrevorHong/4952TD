@page "/Game"

<PageTitle>Index</PageTitle>

<h1>Hello, world!</h1>

<div style="display: flex; flex-direction: row;">
    <svg tabindex="0" height="80vh" width="75vw">
        <rect x="@x" y="@y" height="50" width="50"></rect>
    </svg>

    <nav class="collapse d-lg-block sidebar right-sidebar-menu consistent-header-parent" style="margin-left: auto;">
        <div class="card">
            <div class="card-header" id="headingOne">
             <h5 class="mb-0">
                <button class="btn btn-link collapsed">
                Melee
                </button>
            </h5>
            </div>
            <div class="card-header" id="headingTwo">
             <h5 class="mb-0">
                <button class="btn btn-link collapsed">
                Ranged
                </button>
            </h5>
            </div>
            <div class="card-header" id="headingThree">
             <h5 class="mb-0">
                <button class="btn btn-link collapsed">
                Stun
                </button>
            </h5>
            </div>   
            <div class="card-header" id="headingFour">
             <h5 class="mb-0">
                <button class="btn btn-link collapsed">
                Bomb
                </button>
            </h5>
            </div>              
        </div>
    </nav>
</div>
@code {
    float[] xPosition = { 50, 100, 100, 150, 150, 200 , 250, 500};
    float[] yPosition = { 50, 50, 100, 100, 50, 50, 50, 50};

    float x = 50;
    float y = 50;
    int index = 0;
    
    float factor = 0.01f;

    float speed = 0.01f;
    System.Threading.Timer? timer;

    protected override void OnInitialized() {
        timer = new System.Threading.Timer(MoveAutomatically, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(1));
    }


    /*void GeneratePath(float startX, float startY, ) {

    }*/

    void MoveAutomatically(object? state) {

        Task.Run(() => {

            float newX = Interpolation(x, xPosition[index], factor);

            float newY = Interpolation(y, yPosition[index], factor);

            x = newX;
            y = newY;

            factor += speed;

            if (factor >= 1.0f) {
                index = (index + 1) % xPosition.Length;
                factor -= 1.0f;
            }
        InvokeAsync(() => StateHasChanged());
        });
    }

    float Interpolation(float start, float end, float t) {
        return start + t * (end - start);
    }

    // Dispose the timer when the component is disposed
    /*Task Move(KeyboardEventArgs e) {
        switch(e.Key) {
            case "ArrowDown":
                y++;
                break;
            case "ArrowUp":
                y--;
                break;
            case "ArrowLeft":
                x--;
                break;
            case "ArrowRight":
                x++;
                break;
            default:
                break;
        }
        return Task.CompletedTask;
    }*/
}